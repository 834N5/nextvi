NEXTVI
======

Nextvi is a vi/ex editor.  It can edit bidirectional UTF-8 text.
Based on original software by Ali Gholami Rudi:
https://github.com/aligrudi/neatvi

NOTICE
======
Nextvi is mostly feature complete & solid stable.
No major updates to be expected.
Only small fixes & optimizations.
Code is|(will|must be) perfect.

NAME
======
I believe that this fork has grew to be mature enough to get
it's own name. The project has taken lot of different design
decisions and tends to favor clean implementations over 100%
adhering to POSIX like neatvi does. Thus the name "next", to
signify that we are thinking outside the box. The notable
changes that I am refering to (see below): 56, 60, 61.
Some keybinds specified by posix were not implemented in
original neatvi, nextvi might use them for some features
below.

FORK CHANGES
------------
1. Added unindent keybind: ^w
^w may also take vi_arg1 or motions as a region.
2. Added quickexit to insert mode keybind: kj
It's important to understand that this has a caveat, if
input comes too fast, for example a paste from terminal and
the sequence has "kj" in it, insert mode will be cancelled mid way
and paste will be wrong. Luckly this almost never happens because
such letter combination is extremely rare.
Can be disabled via :se noqe
3. Added linenumbers, keybind: # (relative numbers are placed after indent)
keybind: v# enables permanent line numbers
4. Added invisible character view, keybind: V
5. Added regex for changing spaces to tabs, keybind: vi
6. Added regex for removing /r in dos files and trail space/tab, keybind: vo
7. Changed behavior of ^a to change search direction when no more match. (see 49.)
8. Added fssearch, searches what is under the cursor or (last search kwd)
in every file in the opened directory keybind: ^] or ^5
Beware that it will brute force open files into buffers and
perform the search. I usually save really often so this isn't
a problem, but being careless might reload file with unsaved changes.
By default it checks every file, else filter is specified by :inc (see 32.)
This works in compliance with other changes (see 49. 58.)
Use it for code navigation between files, jump to definitions / etc.
9. fssearch but going in reverse keybind: ^p
10. Added key to change the mark origin which ^p will return to, keybind: ^t
11. Added ex command "ea" which opens file ignoring the path,
setting an extra parameter in form of a number will tell how many matches with
similar filename to skip.
For example file might be named "./path/bla/bla/file123.c" but you can open it
just by "ea fi" if this is a uniquely matched filename.
12. Added ex command "fd" to set the directory for fssearch or "ea" ex command
Running "fd" without an arg will recalculate directory info at current working dir.
13. Added numbered buffers to vi, default 10 and ex "b" command to show buffers
and "b%d" to switch (where %d is the buffer number).
Added new ex command "bx", where the argument will change the number of buffers
allowed. If the number is lower than number of buffers currently in use they
will be deallocated. Running bx without an arg will reset to default value of 10.
Increasing the number of buffers results in a positive effect on performance of
fssearch (8. 9.) if the search keyword does not change. This is because vi 
will remember the position of previous match in the buffer avoiding redundant search.
14. Added key to show buffers and switch buffer
(to switch press corresponding 0-9 number) keybind: ^7
If vi_arg1 is specified right before ^7 the buffer will be switched immediately
which also happens to permit numbers > 9.
15. Added key to exit vi keybind: qq
16. Added key to goto line 0 keybind: gg
17. Added key to delete everything inside (cursor outside) "" keybind: di" or dc"
18. Added key to delete everything inside () keybind: di) or dc)
19. Added key to delete everything inside (cursor outside) () keybind: di( or dc(
20. Added key to change . to -> on cursor line keybind: vh
21. Added key to change -> to . on cursor line keybind: vg
22. Added new ex option "ish", this makes every "!" pipe command
run though interactive shell so that stuff like aliases work. By
default it is enabled, can be disabled if you need to for some
odd reason via :se noish
23. Changed the colors to be based on standard ASCII 16 colors desc in conf.c
Colors can be customized up to 256 colors if your terminal supports it.
24. Added new syntax highlighting for C, js, html, css, diff...
25. Added key that splits the line (opposite of J) keybind: K
K may also take vi_arg1, in which case it will repeat the operation on next line.
26. Added key that line wraps text to 80 line limit keybind: gq
keybind: gw does the same but floors to the last word and is also
much slower. gw is a macro, so set td=2 if there is bidi text, it makes a difference.
27. Added key that does multiline repeated edits keybind: v.
This is based on your last commands and insertions and requires
vi_arg1 for how many lines to repeat said operation. When last
operation was 'i' or other commands that enter insert mode
and some text, that text will be placed at the same offset on
N number of lines specified by the vi_arg1. Direction: top to bottom
28. Added ability to view the numbers for arguments that keys e,w,E,W,b,B
may take. keybind: ^v Pressing again will change the key mode, specifying
any vi_arg1 will exit the mode. This is a major step up to how navigation
works in vi, it makes it so much easier to use because now you can see where
you are going. These special numbers and their colors can be customized
through conf.c. If not for anything else I suggest you to try out this distro
just to see it in action.
29. Added ability to change highlight dynamically. (via syn_reloadft();)
30. New ex option "hlw" which highlights every instance of word on the
screen based on cursor position. Useful for when studying source code.
31. Added autocomplete in insert mode. Press ^g to index the current opened
file. Then you can press ^n to cycle though the options, results are based on
the contents of the file and the closest match to what you typed. Use ^r to
cycle in reverse.
By default it will use big regex like [^;...]* to sort out all the punctuation
chars from words and build a database of words. But in order to take full
advantage out of the completion system, you can change this regex at runtime
using new ex command "ac". For example say we don't want word completion
and we want entire line completion instead, run :ac .*
If the regex rule allows inclusion of nonalphanumeric or punctuation characters
you won't be able to retreive the string like it works with words by default.
Automatically determening the position from which completion starts
inside insert sbuf is ambiguous. More fine tuned control is needed and
can be achieved using new keybind ^z in insert. Use ^z before you type out 
search term, this will set start position for completion, such
that the options can be looped over inplace. ^z is a toggle, to disable
it (without exiting insert) press twice in same place. When ^z is set
^u keybind will delete everything until ^z mark first, otherwise ^u
operates normally (deletes everything).
You will find that the autocomplete db is persistent throughout
all buffers and it also has data duplication and redundancy checking
such that you can index multiple files as you need in your workflow,
maybe even using different filter rules. 
Like ^g used to index file in insert mode you can use ^y from insert
to out clear the completion db.
Running ex command "ac" with no argument will reset back to the default
word filtering regex. You can find it's string in led.c as a reference.
32. Added ex command "inc" which sets the path filter using regex. For
example we want to get only files in submodule directory that end
with .c extension, use: :inc submodule.*\.c$
Running "inc" without an arg will disable all filters.
33. Added file manager keybind: \
Until commit 382c65b nextvi had a full filemanager
called hund built in. It acted as temporary workaround,
until I got to properly implement file management in vi
itself. This should be a lot cleaner and a more flexible
than having hund. As time goes on there will be added
some new ex commands to help working with files. All
done from a vi buffer. Commands listed below under (33.)
will also work everywhere in vi.
 - New ex command "cd" changes working directory according to 1st arg.
 - (32.), (12.) and ex "cd" affect how/what dirs & files are listed.
 - Added key that opens the file based on text from the cursor.
   keybind: ^i or TAB
 - when inside /fm/ presing keybind \ again will dynamically update the
   directory info at current working dir.
34. Added key to save current file keybind: ^k
35. The new special character "/" for ft in conf.c now signifies that
the regex will be applied on any file. The reason "/" was
chosen because it's forbidden filename character on unix. It used
to be "" but in C will make a ptr value of 0, which breaks strcmp
which is used to match highlights.
36. Added a window size signal handler for vi to
redraw the screen automatically.
37. Added history buffer for ex commands when in vi prompt.
keybind: ^b or vb (from normal) will open the buffer with all previous
commands move the cursor to wanted command and exit buffer with qq
will copy the command into prompt. You can also use this
when half way through some command and need to access normal
mode to edit the command more efficiently. The filename is named 
"/hist/" so that it can't be written to file with ^k (by accident).
If you want to save history to file use :w yourfilename
38. Added key to grab the current word(s) under the cursor into
prompt like so :%s/.../ keybind: vr (see also 49.)
39. Added ex option to change number of spaces in a tab (\t)
default is set to 8. use :se tbs=N  (N is number of spaces)
40. Added partial support for multiline block regex, for
example C multiline comments syntax highlight.
41. Made lowest row to not waste any space when there
are no messages and actually display the row.
42. Search via '/' or '?' automatically centers and redraws
screen. This partly because change in 41 makes the bottom row
behave dynamically and you might get search result on displayed
on that row, which will be covered by search message instead.
Also, centering is nice because you always know where to expect
the result to be with your eyes.
43. Added terminal clean up on exit
44. Added a key to perform relative word replacements keybind: vt
Specify vi_arg1 and the word(s) under the cursor will be placed into prompt,
for example :.,.+5s/\<word\>/ where 5 is vi_arg1. (see also 49.)
45. Improved single line performance by roughly 3x. Syntax hilight
will not render anything beyond the terminal colums.
If there is a line in the file that has say 200K characters, the
performance will not degrade. This was extremely difficult to get
right and took me 3 weeks of refactors because we also have to
take into account:
	1. Bidi text direction.
	2. Multibyte UTF-8. Double width chars.
	3. Variable width tabulations that can change
	throughout the line based on surroundings.
	4. Reordering of characters.
See also PERFORMANCE section at the end of the file
46. Added key to abandon insert discarding any changes keybind: ^x
That means there are 4 ways to exit insert|prompt now: ^x, ^c, ESC, kj
RATIONALE: unlike others, ^x will not leave file marked as modified.
47. Added Russian keymap, and changed how xkmap_alt works, now
z + vi_arg1 in normal mode will switch what keymap ^f key changes,
so for example 1 = fa 2 = ru. If you need some other language
kmap just make one yourself. Look into kmap.h it's really simple.
kmap also has digraph support, that list has been expanded to
include non printing characters. Naming resembles ASCII caret
notation, so for example 03 is key ^c to be able to type 03
enter insert, use ^k to go into digraph mode, type then " c" (space+c)
Essentially space is representing typeable ctrl key.
The reason this is useful is if you are using @ key to make macros
there has to be a way to type these control characters.
Alternatively, it's possible to type the character literal using
^a + ^(insertkeyhere). In neatvi this was binded to
^v, currently ^v is used for 48. Nextvi shall keep both, the digraph
way and ^a for clarity and better user reference, no more searching
ascii keycodes online if kmap has it in the clear.
48. Improvement to change 37. Now when in prompt/insert ^v will bring
up the latest command from history. Also the history works for
searches via / or ? the same way. keybind vv does the same but from
normal mode, to save time. Pressing ^v again goes to next string.
49. Added ability to get more than 1 word for keybinds ^a ^] ^p vr vt v/
specified by number (vi_arg1). Regex control chars will be escaped.
vr vt v/ ^] ^p will grab word(s) only if vi_arg1 >= 1 otherwise
the keybind will perform a default cursor independent action.
50. Added ability to edit the line while in insert mode
such that backspace can delete all the characters on the line,
when no more characters left the line will be wrapped onto the next
one. This is behavior you can expect from 95% of editors, now nextvi
is not an exception. The same change was done for ^w keybind.
51. Added key to show the registers and their contents. keybind: R
52. Made feature of reverse text highlight toggleable via new ex option "hlr"
53. Added a key to disable autoindent. keybind: va
This is necessary sometimes if you want to paste from system clipboard.
54. Removed full names of ex commands and options, (seriously, who uses that?)
now only short and fast to type abbreviations work.
55. Substitute undo-redo point return to where command was issued initially
if the affected area is greater than terminal rows.
56. Modified regex engine to support more than 1 character in negated
char expressions. For example [^&&abc] where ^&& is the not+and. This will
treat "abc" as !(a && b && c) logically. Everything in brackets preceding
&& will be processed according to standard negated char exp.
57. Added ^l key in insert to clean the terminal and start at line 0,
remove distrations and focus on typing. Useful when running ex via vi -e
58. Added v/ key in normal, which can grab the current word(s) under the
cursor into prompt and set the current search string. If valid, the input
will be used for all search related operations in vi. (see 49.)
59. Added ability to remember scroll amount for ^e and ^y keys (specified by vi_arg1).
I felt like they were underused, and unlike ^u and ^d they keep the same
xcol position, allowing for different use case when you don't want to
lose cursor pos.
60. Removed bracket classes from regex. Not useful, hard to customize,
buggy, error prone mess. Doesn't add any new functionality to the regex engine
that can't be achieved without it.
61. Nextvi special character escapes work mostly the same way
everywhere except the following situations:
 - Escapes in regex bracket expressions. This isn't posix but it
solves couple of issues that were bugged previously, like escaping | in
ex substitution command, properly counting number of groups in rset.
 - A single slash requires 2 slashes, and so on.
 - rset_make() requires for ( to be escaped if used inside [] brackets.
 - In ex prompt the only separator is "|" character and there is some
   counter intuivite handling of escapes done that has to be explained.
	1: to use ex separator input "|"
	2: to get "|" into the result string input = "\\|"
	3: to get "\|" into the result string input = "\|"
	4: to get "\\|" into the result string input = "\\\|"
	5: to get "\\\|" into the result string input = "\\\\|"
   A careful reader will spot that the rules above don't exactly
   follow the well established rule - "2 slashes make one". This is
   because to allow any combination of "|" and "\" one would have to
   force a "4 slashes make one" rule. Imagine having to type "\\("
   to escape "(" instead of "\(" everywhere if we want to be consistent.
   The latter sucks, so instead we make this special case for ex prompt
   that applies only to "|" and "\". In summary, just remeber what clauses
   (2:) and (3:) state, for cases where there are lots of slashes the
   rule is input minus 1 of the "\" equals the output string. Keep in mind
   that various ex functions, for example regex will consume extra slashes
   internally if there is more than 1 after another.
   If we wanted to match string "\\|" input will be: "\\\\\\|"
   "\\\|" will get us "\\|" into regex, but the input
   needs 3 more slashes because +1 rule (5:) +2 rule 2 slashes make 1.
   timeline: "\\\\\\|" -> rule(5:) "\\\\\|" -> rule(regex:2 = 1) "\\\|" =
   rule(regex:"\|" = "|") "\\|" = this is the literal we wanted to match!
62. Added syntax highlighting continuation options. See the struct
highlight in vi.h. The ^ anchor in the regular expression has an important
property of being able to efficiently exclude some sub expression from
being recomputed during the continuation. Take advantage of it when you
can.
63. New ex option "hlp", will highlight closest pair of symbols {([
from the cursor, the same way % key works.
Notes:
This feature wasn't really supposed to be getting into nextvi
and was a product of me testing out the syntax highlighting capabilities.
The fact that this is possible in the first place is quite impressive,
remember that %100 of hl is computed using 1 regular expression. There
isn't any extra logic involved except change (29.). In no way would
I ever call this implementation efficient or optimal, but at least
it will run fast enough on most chips and is fully optional.
64. Ex options "hll", "hlw", "hlp" and any others that may or may not
be created in the future are fully customizeable in conf.c the same
way you customize per ft highlighting. They must have highlight->func
struct member set. If ft does not provide a spot in hl, the latter
feature will not work on that ft, regardless of ex options being set.
65. Added a key to quickly access :! prompt. keybind: v;
Removed "make" ex command. Commands like these are not wanted, nextvi
shall provide a more general purpose solution for the user, like the
keybind v; for example.
66. Added new ex option "grp". The following allows you to define the
search group for / ? n N (31.) autocomplete and ex substitution. This becomes
necessary if you want the result of regex search to be based on some group rather
than default match group. For example you want to search for the whole
line but exclude the tabs at the beginning of the line, use regex like
this: [	]+(.[^ ]+) since we only want the capture result for our search
use the "grp" like this: :se grp=4 .The number 4 is important,
it is calculated using: grpnum * 2, to get the second group number
do: 2 * 2 = 4. The first group is always 2, 1 * 2 = 2, :se grp=2 gets you
back to default behavior when you are done using it.
67. Undo and Redo commands (u,^r) may take optional vi_arg1 which
repeats the operation N times.
68. Search motions do not terminate with error if the count is greater than 
number of instances found. Last possible match will be used. Important when
you don't know exactly how many matches there are, does not mean there aren't
any at all, greedy behavior opens up new use cases.

PIKEVM:
-------
A complete rewrite of nextvi's regex engine for the purposes to get
rid of backtracking and severe performance and memory constrants is
now complete. See FAQ below.

FAQ:
----
Q: Why nextvi instead of vim?
A: I prefer customization in source code, Vim is considered harmful.

Q: Why not distribute as patches, like on suckless.org?
A: It's hard to maintain. Simply put, there are too many changes
to keep track of.

Q: General philosophy?
A: User is programmer, hacker culture.
In most texteditors, flexibility is a minor or irrelevant design goal.
Nextvi is designed to be flexible where the editor adapts to the user
needs. This flexibility is achieved by heavily chaining basic
commands and allowing them to create new ones with completely
different functionality. Command reuse keeps the editor small without
infringing on your freedom to quickly get a good grasp on the code.
If you want to customize anything, you should be able to do it using
the only core commands or a mix with some specific C code for
more difficult tasks. Simple and flexible design allows for
straight forward solutions to any problem long term and filters
bad inconsistent ideas.
You should never find yourself in a situation where feature "a"
is only really usable under certain conditions / enviroment
and has a specific implementation which can never
be used for anything else - this is bloat. Unfortunately I have
not seen a single text editor who's goal is to not crap pile in as many
features as possible, but to only address the core nature of text
manipulation and its logistics. Adding 4 new scripting languages, 20 rust
dependencies, making gpu accelerated gui, nesting 100s of small files in a 5
level deep directory structure, waiting 5 minutes for git clone, compiling for
30 minutes, we've all seen it. NOBODY asked for that, yet they all do it, and
most either don't care or remain ignorant. Does all this help users to better
understand the software they use? Does this help users to be creative and
learn to do things themselves instead of relying on sucky implementations,
whence it's not even clear where they start or do they end? Developer might
look smart, but the doctor was right - symptoms are of intergluteal cleft.
"But they are developers they know better, right?" - False, they force you to
eat their shit which you can't opt out of or change easily. Even worse, often
they are incompetent to fix problems they created themselves. My goal is to
learn from past mistakes/successes, optimizing for the best featureset
effective yield ratio proven by time. Therefore, a lot more thought and
consideration is to be put into every feature. It would be too difficult to
define precise formula of "reasonableness", with simplification it comes down
to a few of my rules in the order:
	1. Number of cpu cycles taken * complexity of required result
	2. How does the feature improve/affect other existing features
	3. How does the feature address the main problem of the program,
	universality, how often it will be used, number of cases covered
	4. Number of lines of code in implementation (raw)
Now assign some weight value to each of those points and multiply by
their order number and sum everything up. The final value would determine
the "reasonableness", bigger means better. As the smartest programmer once
said that figuring out this "reasonableness" is the hardest question in
programming.

Q: Keybind with CTRL does not work?
A: vi is reading ASCII codes sent by the terminal. Depending on the
keyboard, the ASCII code could be another key combination. It was
reported that "^^" (Ctrl + ^) can be achieved on some system with "^6".
If something doesn't work, have a look at the layout of an
american/british keyboard and try to reproduce the keybind as if you
have an american/british keyboard.

Q: Something, something - pikevm
A: Pikevm guarantees that all regular expressions are computed in
constant space and O(n+k) time where n is size of the string and
k is some constant for the complexity of the regex ie. how big it is.
Q: What are the other benefits?
A: For example, now it is possible to compute a C comment /* n */
where n can be an infinite number of characters. Of course this
extends to every other valid regular expression.
A: Minimalism?
Q: Implementation (regex.c) is ~650 lines of C code, that
includes both the compilation and execution.
Q: NFA vs DFA (identify)
A: pikevm = NFA backtrack = DFA
Q: What's wrong with original implementation?
A: Nothing except it being slow and limited. My improved version
of Ali's DFA implementation ran 2X faster in any case, however
I found a bug with it where quested "?" nested groups compute
wrong submatch results. To fix this problem, it would require
to undo a lot of optimization work already done, basically
going back to how slow Ali's implementation would be. The
reason this was spoted so late was because this kind of
regex wasn't used before, so I never tested it. Other than
that I think submatch extraction is correct on other cases.
Pikevm does not have this bug, so it will be used as main
regex engine from now on, unless dfa ever finds a proper fix.
Honestly, this change isn't so suprising, as I was working
on pikevm a few months prior, to favor a superior algorithm.
You can still find that code here (likely with no updates):
https://github.com/kyx0r/nextvi/tree/dfa_dead

Q: What does it mean when I call feature X a macro?
A: It's the kind of shortcut that does not change the core
functionality, but rather reuses the core functionality.
Usually macro features are implemented in 1 or a few lines
of code. Notably, they tend to use function term_push(), but
it's not required. Because they are macros they may run suboptimally
or not handle every possible edge case.
These features are considered a macro: 5. 6. 17. 18. 19. 20.
21. 26. 27. 34. 46. 50. 65.

CONFIGURATION
-------------
Edit conf.c to adjust syntax highlighting rules and text direction
patterns.  To define a new keymap, create a new array in kmap.h, like
kmap_fa, and add it to kmaps array in the same header (the first entry
of the new array specifies its name).  The current keymap may be
changed with :cm ex command.  When in input mode, ^e activates the
English kaymap and ^f switches to the alternate keymap (the last
keymap specified with :cm).
Edit ex.c to set default ex variables or use EXINIT environment
variable as shown under OPTIONS section.

COMMANDS
--------
:cm[ap][!] [kmap]
  Without kmap, prints the current keymap name.
  When kmap is specified, sets the alternate keymap to
  kmap and, unless ! is given, switches to this keymap.
:ft [filetype]
  Without filetype, prints the current file type and
  reloads the highlight ft, makes it possible to reset
  dynamic hilights created by options like "hlw".
  When filetype is specified, sets the file type of the
  current ex buffer.

New key mappings:
^a in normal mode: searches for the word under the cursor.
^p in insert mode: inserts the contents of the default yank buffer.
zL, zl, zr, and zR in normal mode: change the value of td option.
^e and ^f in insert mode: switch to the English and alternate keymap.
ze and zf in normal mode: switch to the English and alternate keymap.
gu, gU, and g~ in normal mode: switch character case.
^l in normal mode: updates terminal dimensions (after resizing it).

LESSER KNOWN FEATURES
---------------------
- "Ever tried reading the source code?"
Yes, that is a lesser known feature, what did you expect?
Jokes aside (with a level of truth to it), these features exist
in many other vi implementations but neither man pages cover their
functionality in an understandable language, describe it here instead.

- @@ macros:
1. Type out the macro or load from file such that it is in some vi buffer.
2. Use keybind "ayy on the macro, this will store it in register 'a'
3. Use @a to play it back, where a stands for that 'a' register
4. @@ repeats the last macro on next line

- substitution backreference
This inserts the text of matched group specified by \x where x is
group number. Example:
this is an example text for subs and has int or void
:%s/(int)\\|(void)/pre\0after
this is an example text for subs and has preintafter or void
:%s/(int)\\|(void)/pre\2after/g
this is an example text for subs and has prepreafterafter or prevoidafter

- ex global command
same syntax as ex substitution command, but instead of replacement
string it takes an ex command after the / / enclosed regex.
Example: remove empty lines
:g/^\n/d
Try doing similar with substitution command - will not work as removing '\n'
without deleting the line is invalid, but it will work with global command.
Note: '\n' character used in example is for illustration purpose only.
Typing '\n' is possible, see (47.)

- search motions
? and / searches have the ability to be used as motions. This seems very
counter intuitive and one would have never ever figure out that this
feature even exists, unless noted. Even if you read the source code it's
very easy to miss. How to use: optionally specify vi_arg1, specify the motion
using it's keybind, then do / or ? and type out the search term.
The motion ends on the first match by default (no vi_arg1 specified).
The optional vi_arg1 determines how many matches of the term to skip until the
motion ends. Example: you see that the next 10 lines have the word "int"
which is included 3 times. You want to delete text until the 3rd
instance of "int" keybind would be 3d/int . Likewise you can opt out
of the "specify motion" part and just use / or ? with vi_arg1 to perform
specific searches.

OPTIONS
-------

To improve nextvi's performance, shaping, character reordering, and
syntax highlighting can be disabled by defining the EXINIT environment
variable as "se noshape | se noorder | se nohl | se td=+2".

Options supported in nextvi:

td
  Current direction context.  The following values are meaningful:
  * +2: always left-to-right.
  * +1: follow conf.c's dircontexts[]; left-to-right for others.
  * -1: follow conf.c's dircontexts[]; right-to-left for others.
  * -2: always right-to-left.
shape
  If set (default), performs Arabic/Farsi letter shaping.
order
  If set, reorder characters based on the rules defined
  in conf.c.
hl
  If set (default), text will be highlighted based on syntax
  highlighting rules in conf.c.
hll
  If set, highlight current line.
ai
  As in vi(1).
aw
  As in vi(1).
ic
  As in vi(1).

MARKS AND BUFFERS
-----------------

Special marks:
* the position of the previous change
[ the first line of the previous change
] the last line of the previous change

Special yank buffers:
/ the previous search keyword
: the previous ex command

PERFORMANCE
-----------
Stress test:
1. Compile both versions with gcc -O2 -g (no customizations done)
2. Open Nextvi's vi.c and hold ^d until the end of the file
3. Capture the results with callgrind:

ORIGINAL NEATVI:
--------------------------------------------------------------------------------
979,710,902 (100.0%)  PROGRAM TOTALS
--------------------------------------------------------------------------------
232,844,791 (23.77%)  ???:re_rec [/root/neatvi/vi]
194,719,965 (19.88%)  ???:brk_match [/root/neatvi/vi]
/* brk_match is terrible, can be optimized down to a simple loop
which is what was done in branch dfa_dead. Still recursion is
utterly slow. For the curious reader, total cost of regex
operations is 745,481,975. dfa_dead version of regex runs
with total of 350,000,000 (including cost of extra 20+ alternations
and extra backtracking patterns). If tested under the same default
regex patterns of neatvi, the cost would be exactly 195,494,596.
Imagine how much faster Ali's regex could of been if it was written
free of bullshit. To put in perspective, on raspberry pi 3b+ the
difference between 195,494,596 and 745,481,975 refs is maxing 
the core cpu usage at ~20% VS 100%++ . If you are running hardware
from 2000s take a shot each time you wanna scroll up or down, as
words cannot even begin to describe the slideshow you would see. */
171,305,604 (17.49%)  ???:re_rec'2 [/root/neatvi/vi]
111,565,533 (11.39%)  ???:uc_dec [/root/neatvi/vi]
 35,046,082 ( 3.58%)  ???:regexec [/root/neatvi/vi]
 25,085,560 ( 2.56%)  ???:ren_placeholder [/root/neatvi/vi]
 25,036,554 ( 2.56%)  ???:led_render [/root/neatvi/vi]
 21,459,676 ( 2.19%)  ???:sbuf_str [/root/neatvi/vi]
 20,519,232 ( 2.09%)  ???:conf_placeholder [/root/neatvi/vi]
 15,621,754 ( 1.59%)  ???:sbuf_chr [/root/neatvi/vi]
  9,720,150 ( 0.99%)  /string/x86_64/memcpy.s:0x0000000000079792 [/usr/lib/libc.so]
  7,811,386 ( 0.80%)  /malloc/mallocng/meta.h:__libc_malloc_impl [/usr/lib/libc.so]
  6,598,026 ( 0.67%)  /string/strlen.c:strlen [/usr/lib/libc.so]
  6,476,181 ( 0.66%)  /stdio/vfprintf.c:printf_core [/usr/lib/libc.so]
  6,020,010 ( 0.61%)  ???:rset_find [/root/neatvi/vi]
  5,688,194 ( 0.58%)  ???:uc_chop [/root/neatvi/vi]
  5,400,897 ( 0.55%)  /malloc/mallocng/meta.h:get_meta [/usr/lib/libc.so]
  4,920,813 ( 0.50%)  /malloc/mallocng/free.c:__libc_free [/usr/lib/libc.so]
  4,465,120 ( 0.46%)  /ctype/isalnum.c:isalnum [/usr/lib/libc.so]
  4,274,163 ( 0.44%)  ???:syn_highlight [/root/neatvi/vi]
  3,894,174 ( 0.40%)  ???:ren_cwid [/root/neatvi/vi]
  3,738,161 ( 0.38%)  ???:uc_off [/root/neatvi/vi]
  3,564,125 ( 0.36%)  /malloc/mallocng/malloc.c:__libc_malloc_impl
  3,401,078 ( 0.35%)  /malloc/mallocng/meta.h:__libc_free
  3,283,304 ( 0.34%)  ???:term_att [/root/neatvi/vi]
  3,241,094 ( 0.33%)  ???:ren_position [/root/neatvi/vi]
  3,230,544 ( 0.33%)  ???:uc_shape [/root/neatvi/vi]
  3,118,323 ( 0.32%)  ???:uc_isbell [/root/neatvi/vi]
  3,118,323 ( 0.32%)  ???:uc_iscomb [/root/neatvi/vi]
  2,845,860 ( 0.29%)  ???:led_offdir [/root/neatvi/vi]
  2,486,505 ( 0.25%)  ???:uc_code [/root/neatvi/vi]
  2,352,300 ( 0.24%)  ???:sbuf_mem [/root/neatvi/vi]
  2,297,839 ( 0.23%)  /malloc/mallocng/malloc.c:alloc_slot [/usr/lib/libc.so]
  2,105,241 ( 0.21%)  /stdio/fwrite.c:__fwritex [/usr/lib/libc.so]
  1,710,288 ( 0.17%)  ???:ren_translate [/root/neatvi/vi]
  1,557,840 ( 0.16%)  ???:uc_wid [/root/neatvi/vi]
  1,438,331 ( 0.15%)  /malloc/mallocng/free.c:nontrivial_free [/usr/lib/libc.so]
  1,187,547 ( 0.12%)  /malloc/mallocng/meta.h:alloc_slot
  1,144,685 ( 0.12%)  ./src/internal/atomic.h:__libc_malloc_impl
  1,140,192 ( 0.12%)  ???:uc_isprint [/root/neatvi/vi]
  1,067,801 ( 0.11%)  /stdio/vfprintf.c:vfprintf [/usr/lib/libc.so]
  1,004,876 ( 0.10%)  /malloc/mallocng/meta.h:__malloc_allzerop [/usr/lib/libc.so]
    823,571 ( 0.08%)  ???:uc_slen [/root/neatvi/vi]
    807,400 ( 0.08%)  ???:uc_len [/root/neatvi/vi]
    673,855 ( 0.07%)  /stdio/vsnprintf.c:vsnprintf [/usr/lib/libc.so]
    652,657 ( 0.07%)  /string/strchrnul.c:strchrnul [/usr/lib/libc.so]

NEXTVI:
--------------------------------------------------------------------------------
447,818,162 (100.0%)  PROGRAM TOTALS
--------------------------------------------------------------------------------
338,052,852 (75.49%)  regex.c:re_pikevm [/root/klec/cprogs/nextvi/vi]
/* 70% of this time is taken up by bookkeeping the NFA states */
 45,392,967 (10.14%)  /string/x86_64/memcpy.s:0x0000000000079792 [/usr/lib/libc.so]
/* this memcpy is the cost of submatch tracking, my improved version of
Cox's algorithm at work, pulling great stats */
 13,196,403 ( 2.95%)  led.c:led_render [/root/klec/cprogs/nextvi/vi]
  6,039,280 ( 1.35%)  /ctype/isalnum.c:isalnum [/usr/lib/libc.so]
/* surprising: isalnum() is recomputed per character here multiple times due to it
being used in syntax hl patterns multiple times. Maybe regex could be constructed
more efficiently. */
  4,117,540 ( 0.92%)  ren.c:ren_cwid [/root/klec/cprogs/nextvi/vi]
/* ren_cwid is stupid, gets computed twice per character, when reorder does not
apply needs to be computed only once. Planning to rework in the future.
  4,015,727 ( 0.90%)  ren.c:ren_translate [/root/klec/cprogs/nextvi/vi]
  3,614,015 ( 0.81%)  /stdio/vfprintf.c:printf_core [/usr/lib/libc.so]
/* term_pos(), term_room() */
  2,966,279 ( 0.66%)  regex.c:rset_find [/root/klec/cprogs/nextvi/vi]
  2,659,889 ( 0.59%)  sbuf.c:sbuf_mem [/root/klec/cprogs/nextvi/vi]
  2,491,262 ( 0.56%)  uc.c:uc_off [/root/klec/cprogs/nextvi/vi]
  2,345,893 ( 0.52%)  ren.c:syn_highlight [/root/klec/cprogs/nextvi/vi]
  2,225,175 ( 0.50%)  /string/x86_64/memset.s:0x00000000000797e9 [/usr/lib/libc.so]
  1,397,128 ( 0.31%)  /string/x86_64/memmove.s:0x00000000000797c4 [/usr/lib/libc.so]
  1,292,421 ( 0.29%)  /stdio/fwrite.c:__fwritex [/usr/lib/libc.so]
  1,086,179 ( 0.24%)  ren.c:ren_position [/root/klec/cprogs/nextvi/vi]
  1,022,134 ( 0.23%)  uc.c:uc_chop [/root/klec/cprogs/nextvi/vi]
    958,931 ( 0.21%)  /malloc/mallocng/meta.h:__libc_malloc_impl [/usr/lib/libc.so]
    891,770 ( 0.20%)  uc.c:uc_isbell [/root/klec/cprogs/nextvi/vi]
    856,750 ( 0.19%)  uc.c:uc_wid [/root/klec/cprogs/nextvi/vi]
    840,501 ( 0.19%)  uc.c:uc_shape [/root/klec/cprogs/nextvi/vi]
    798,381 ( 0.18%)  uc.c:uc_iscomb [/root/klec/cprogs/nextvi/vi]
    754,726 ( 0.17%)  uc.c:uc_slen [/root/klec/cprogs/nextvi/vi]
    748,496 ( 0.17%)  /malloc/mallocng/meta.h:get_meta [/usr/lib/libc.so]
    742,164 ( 0.17%)  /string/strlen.c:strlen [/usr/lib/libc.so]
    652,619 ( 0.15%)  /string/strchrnul.c:strchrnul [/usr/lib/libc.so]
    583,186 ( 0.13%)  /malloc/mallocng/free.c:__libc_free [/usr/lib/libc.so]
    568,357 ( 0.13%)  /malloc/mallocng/malloc.c:alloc_slot [/usr/lib/libc.so]
    477,199 ( 0.11%)  /stdio/vfprintf.c:vfprintf [/usr/lib/libc.so]
    460,979 ( 0.10%)  /malloc/mallocng/malloc.c:__libc_malloc_impl
    460,611 ( 0.10%)  regex.c:_compilecode'2 [/root/klec/cprogs/nextvi/vi]
/* not a big deal but factor out this recursion, 460,611 refs on startup compiles all regexps
(not like you gonna notice the nanosecond difference this has, but we aim for perfection) */
    401,174 ( 0.09%)  /malloc/mallocng/meta.h:__libc_free
    386,635 ( 0.09%)  term.c:term_att [/root/klec/cprogs/nextvi/vi]
    373,556 ( 0.08%)  uc.c:led_render
    365,040 ( 0.08%)  sbuf.c:sbuf_set [/root/klec/cprogs/nextvi/vi]
    342,438 ( 0.08%)  /malloc/mallocng/free.c:nontrivial_free [/usr/lib/libc.so]

- Given more fair conditions the perf gap would be even wider.
- Always check the quantitative quality of the software you use.
- Original implementaion is riddled with redundant allocations
and computations. Don't blame Ali for being sloppy, it's a
inefficiency by choice. In order for Nextvi to exist it has to be
supercede neatvi, which is respectfully shown.
- We produce less lines of code for equivalent execution and it
runs faster. It's easier for you to read, because we have everything
in check, you will be able to read and understand this code faster.

"It’s possible that I understand better what’s going on, or
it’s equally possible that I just think I do."
	— Russ Cox
